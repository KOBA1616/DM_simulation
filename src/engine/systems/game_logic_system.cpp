#include "engine/systems/game_logic_system.hpp"
#include "engine/systems/card/target_utils.hpp"
#include "engine/systems/card/condition_system.hpp"
#include "engine/systems/pipeline_executor.hpp"
#include "core/game_state.hpp"
#include "core/action.hpp"
#include "engine/game_command/commands.hpp"
#include <iostream>
#include <algorithm>

namespace dm::engine::systems {

    using namespace core;
    using namespace game_command;

    void GameLogicSystem::handle_play_card(PipelineExecutor& exec, GameState& state, const Instruction& inst,
                                           const std::map<core::CardID, core::CardDefinition>& card_db) {
        int card_id = exec.resolve_int(inst.args.value("card", 0));
        int instance_id = -1; // Assuming we can resolve instance from context or args?
        // Usually instance_id is passed or we look it up.
        // For PLAY_CARD from hand, we usually have an instance_id in the instruction args if generated by ActionGenerator.

        // Try to get from args, else context
        if (inst.args.contains("card")) {
            instance_id = exec.resolve_int(inst.args["card"]);
        } else {
             // Try "source"
             instance_id = exec.resolve_int(inst.args.value("source", 0));
        }

        CardInstance* card = state.get_card_instance(instance_id);
        if (!card) return; // Error

        // Check if Evolution
        bool is_evolution = false;
        FilterDef evo_filter;
        if (card_db.count(card->card_id)) {
            const auto& def = card_db.at(card->card_id);
            if (def.keywords.evolution) {
                is_evolution = true;
                // Need to find evolution filter. Usually in `races` or specialized field.
                // For now, assume generic evolution (match race).
                // Simplified: We need a target.
                evo_filter.zones = {"BATTLE_ZONE"};
                evo_filter.races = def.races; // Evolution matches race
                // This is a simplification. Real evolution has specific filters.
            }
        }

        if (is_evolution) {
            // Task B: Evolution Logic
            std::string selection_key = "$evo_target";

            // Check if we already have the target (Resume)
            ContextValue val = exec.get_context_var(selection_key);
            std::vector<int> targets;
            if (std::holds_alternative<std::vector<int>>(val)) {
                targets = std::get<std::vector<int>>(val);
            }

            if (targets.empty()) {
                // Pause and ask for target
                // We should verify if there ARE valid targets. If not, can't play?
                // ActionGenerator checks legality. So if we are here, there is a target.

                // Construct Select Instruction to prompt user
                // We manually pause here instead of using InstructionOp::SELECT because we need strict flow.
                exec.waiting_for_key = selection_key;
                exec.execution_paused = true;

                // Setup Query in State
                state.waiting_for_user_input = true;
                state.pending_query = GameState::QueryContext{
                    0, "SELECT_TARGET", {{"min", 1}, {"max", 1}}, {}, {}
                };

                // Populate valid targets for UI
                // Reuse handle_select logic or TargetUtils
                // ...
                return;
            }

            // Execute Evolution
            int base_id = targets[0];
            auto cmd = std::make_unique<AttachCommand>(instance_id, base_id, Zone::HAND);
            state.execute_command(std::move(cmd));

            // Evolution usually has Summoning Sickness = False (inherited, or just false?)
            // Rules: Evolution creatures do NOT have summoning sickness.
            // Inherited state handled in AttachCommand.

        } else {
            // Normal Play
            // Move from Hand to Battle Zone (or Spell -> Graveyard)
             const auto& def = card_db.at(card->card_id);
             Zone dest = Zone::BATTLE;
             if (def.type == CardType::SPELL) dest = Zone::GRAVEYARD;

             auto cmd = std::make_unique<TransitionCommand>(instance_id, Zone::HAND, dest, state.active_player_id);
             state.execute_command(std::move(cmd));
        }

        // Trigger On-Play / Spell Effects
        // Queue RESOLVE_PLAY...
        // For simplicity, we just inject the instruction?
        // Or the instruction loop continues to RESOLVE_PLAY if defined in JSON.
    }

    void GameLogicSystem::handle_resolve_play(PipelineExecutor& exec, GameState& state, const Instruction& inst,
                                              const std::map<core::CardID, core::CardDefinition>& card_db) {
         // Process On-Play effects
    }

    void GameLogicSystem::handle_attack(PipelineExecutor& exec, GameState& state, const Instruction& inst,
                                        const std::map<core::CardID, core::CardDefinition>& card_db) {
         // Tap, check constraints
         int instance_id = exec.resolve_int(inst.args.value("source", 0));
         auto cmd = std::make_unique<MutateCommand>(instance_id, MutateCommand::MutationType::TAP);
         state.execute_command(std::move(cmd));
    }

    void GameLogicSystem::handle_block(PipelineExecutor& exec, GameState& state, const Instruction& inst,
                                       const std::map<core::CardID, core::CardDefinition>& card_db) {
        // ...
    }

    void GameLogicSystem::handle_resolve_battle(PipelineExecutor& exec, GameState& state, const Instruction& inst,
                                                const std::map<core::CardID, core::CardDefinition>& card_db) {
        (void)exec; (void)state; (void)inst; (void)card_db;
        // Compare powers, destroy loser
    }

    void GameLogicSystem::handle_break_shield(PipelineExecutor& exec, GameState& state, const Instruction& inst,
                                              const std::map<core::CardID, core::CardDefinition>& card_db) {
        int shield_id = exec.resolve_int(inst.args.value("shield", -1));
        if (shield_id == -1) return;

        // Move to Hand
        auto cmd = std::make_unique<TransitionCommand>(shield_id, Zone::SHIELD, Zone::HAND, state.active_player_id);
        state.execute_command(std::move(cmd));

        // Task C: S-Trigger Logic
        const auto* card = state.get_card_instance(shield_id);
        if (card && card_db.count(card->card_id)) {
            const auto& def = card_db.at(card->card_id);
            if (def.keywords.shield_trigger) {

                // Check if we already have the decision (Resume)
                std::string decision_key = "$strigger_decision_" + std::to_string(shield_id);
                ContextValue val = exec.get_context_var(decision_key);

                bool use_trigger = false;
                bool decision_made = false;

                if (std::holds_alternative<int>(val)) {
                    use_trigger = std::get<int>(val) == 1;
                    decision_made = true;
                } else if (std::holds_alternative<std::vector<int>>(val)) {
                     // Maybe returned as [1] for yes?
                     const auto& vec = std::get<std::vector<int>>(val);
                     if(!vec.empty()) use_trigger = vec[0] == 1;
                     decision_made = true;
                }

                if (!decision_made) {
                    // Pause and ask
                    std::cout << "[GameLogic] S-Trigger detected: " << def.name << ". Pausing for input." << std::endl;
                    exec.waiting_for_key = decision_key;
                    exec.execution_paused = true;

                    state.waiting_for_user_input = true;
                    state.pending_query = GameState::QueryContext{
                        0, "SELECT_OPTION", {}, {}, {"No", "Yes"} // 0=No, 1=Yes
                    };
                    return;
                }

                if (use_trigger) {
                    std::cout << "[GameLogic] Activating S-Trigger: " << def.name << std::endl;
                    // Queue Play Card (Free)
                    // We can either directly execute commands or inject instructions.
                    // Injecting instruction is better for consistency.
                    // But we are in the middle of a loop.
                    // We can use a PendingEffect logic?
                    // "Reaction Window" usually creates a separate stack.
                    // But for S-Trigger, it resolves immediately after breaking.

                    // Direct execution for now:
                    // 1. Play (Transition to Battle/Grave)
                    Zone dest = (def.type == CardType::SPELL) ? Zone::GRAVEYARD : Zone::BATTLE;
                    auto play_cmd = std::make_unique<TransitionCommand>(shield_id, Zone::HAND, dest, state.active_player_id);
                    state.execute_command(std::move(play_cmd));

                    // 2. Resolve Effect
                    // This requires running the card's effect script.
                    // We can spawn a new PipelineExecutor? Or use the current one?
                    // If we use current one, we push instructions.
                    // We need `def.effects`.
                    // We can push a new frame!
                    // exec.call_stack.push_back({&def.effects, 0});

                    // However, `def.effects` is `std::vector<EffectDef>`.
                    // We need `std::vector<Instruction>`.
                    // The architecture seems to imply `EffectDef` contains instructions or is convertible?
                    // Checking `card_json_types.hpp` would clarify.
                    // Assuming we have a way to get instructions.
                    // If not, we skip effect execution for this MVP.
                    std::cout << "[GameLogic] (Stub) Executing S-Trigger effects..." << std::endl;
                }
            }
        }
    }

    void GameLogicSystem::handle_mana_charge(PipelineExecutor& exec, GameState& state, const Instruction& inst) {
         (void)exec; (void)state; (void)inst;
         // ...
    }

    void GameLogicSystem::handle_resolve_reaction(PipelineExecutor& exec, GameState& state, const Instruction& inst,
                                                  const std::map<core::CardID, core::CardDefinition>& card_db) {
         (void)exec; (void)state; (void)inst; (void)card_db;
         // ...
    }

    void GameLogicSystem::handle_use_ability(PipelineExecutor& exec, GameState& state, const Instruction& inst,
                                             const std::map<core::CardID, core::CardDefinition>& card_db) {
         (void)exec; (void)state; (void)inst; (void)card_db;
         // ...
    }

    void GameLogicSystem::handle_select_target(PipelineExecutor& exec, GameState& state, const Instruction& inst) {
        (void)state; (void)inst;
        exec.execution_paused = true;
        // ... set query ...
    }

}
