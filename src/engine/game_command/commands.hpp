#pragma once
#include "game_command.hpp"
#include "core/types.hpp"
#include "core/card_def.hpp" // For FilterDef

namespace dm::engine::game_command {

    class TransitionCommand : public GameCommand {
    public:
        int card_instance_id;
        core::Zone from_zone;
        core::Zone to_zone;
        core::PlayerID owner_id;
        int destination_index; // -1 for append

        // Context to restore exact position in from_zone for undo
        int original_index;

        TransitionCommand(int instance_id, core::Zone from, core::Zone to, core::PlayerID owner, int dest_idx = -1)
            : card_instance_id(instance_id), from_zone(from), to_zone(to), owner_id(owner), destination_index(dest_idx), original_index(-1) {}

        void execute(core::GameState& state) override;
        void invert(core::GameState& state) override;
        CommandType get_type() const override { return CommandType::TRANSITION; }
    };

    class MutateCommand : public GameCommand {
    public:
        enum class MutationType {
            TAP,
            UNTAP,
            POWER_MOD,
            ADD_KEYWORD,
            REMOVE_KEYWORD,
            // New types for Global Modifiers
            ADD_GLOBAL_MODIFIER, // For CostModifier
            REMOVE_GLOBAL_MODIFIER,
            ADD_PASSIVE_EFFECT, // For PassiveEffect
            REMOVE_PASSIVE_EFFECT
        };

        int target_instance_id; // For card mutations. -1 or ignored for Global.
        MutationType mutation_type;
        int int_value; // Power value, or reduction amount, or simple int param
        std::string str_value; // Keyword string, etc.

        // Additional fields for global modifiers
        // Since GameCommand is a "Primitive", we avoid complex structs if possible,
        // but adding CostModifier/PassiveEffect requires carrying their data.
        // We can use a shared_ptr to a context object or just add fields.
        // Given CostModifier and PassiveEffect are structs, we can store them.
        // Or store a "modifier_id" if we have a manager? Currently just vectors in GameState.

        // We will store the data needed to construct/remove them.
        // For removal (undo), we might need the index or ID.
        // Currently GameState stores them in vectors without unique IDs.
        // This is tricky for undo unless we strictly pop back or store index.
        // If we treat GameState modifiers as a stack (LIFO), "REMOVE" is just pop_back?
        // But expiration happens out of order?
        // No, modifiers are usually added/expired.
        // For this task (undo support), LIFO is safest if we assume valid nesting.
        // But expiration isn't LIFO.
        // However, GameCommand is for atomic actions. Expiration happens at Flow points.
        // So for "APPLY_MODIFIER", it's just ADD. "REMOVE" is for Undo.
        // Expiration is a separate "EXPIRE_MODIFIER" command generated by Flow? Or just state update.
        // The requirement is "generalize APPLY_MODIFIER (wrapper for GameCommand)".
        // So we need an ADD command.

        // We need to carry the definition of the modifier/passive.
        core::FilterDef filter;
        core::ConditionDef condition;
        int duration; // turns
        core::PlayerID controller;
        int source_id;

        // Undo context
        int previous_int_value;
        bool previous_bool_value;
        // For vector add/remove, we need the index where it was added?
        int added_index = -1;

        MutateCommand(int instance_id, MutationType type, int val = 0, std::string str = "")
            : target_instance_id(instance_id), mutation_type(type), int_value(val), str_value(str),
              duration(0), controller(0), source_id(-1), previous_int_value(0), previous_bool_value(false) {}

        // Enhanced constructor for modifiers
        void set_modifier_data(const core::FilterDef& f, int dur, core::PlayerID ctrl, int src, const core::ConditionDef& cond = {}) {
            filter = f;
            duration = dur;
            controller = ctrl;
            source_id = src;
            condition = cond;
        }

        void execute(core::GameState& state) override;
        void invert(core::GameState& state) override;
        CommandType get_type() const override { return CommandType::MUTATE; }
    };

    class FlowCommand : public GameCommand {
    public:
        enum class FlowType {
            PHASE_CHANGE,
            TURN_CHANGE,
            STEP_CHANGE // Future use
        };

        FlowType flow_type;
        int new_value; // Phase enum or Turn number

        // Undo context
        int previous_value;

        FlowCommand(FlowType type, int val)
            : flow_type(type), new_value(val), previous_value(0) {}

        void execute(core::GameState& state) override;
        void invert(core::GameState& state) override;
        CommandType get_type() const override { return CommandType::FLOW; }
    };

    class QueryCommand : public GameCommand {
    public:
        std::string query_type;
        std::vector<int> valid_targets;
        std::map<std::string, int> params;

        QueryCommand(std::string type, std::vector<int> targets = {}, std::map<std::string, int> p = {})
            : query_type(type), valid_targets(targets), params(p) {}

        void execute(core::GameState& state) override;
        void invert(core::GameState& state) override; // Clears the query
        CommandType get_type() const override { return CommandType::QUERY; }
    };

    class DecideCommand : public GameCommand {
    public:
        int query_id; // To match the query
        std::vector<int> selected_indices; // or instance_ids
        int selected_option_index;

        // Undo context
        bool was_waiting;
        std::optional<core::GameState::QueryContext> previous_query;

        DecideCommand(int q_id, std::vector<int> selection = {}, int option = -1)
            : query_id(q_id), selected_indices(selection), selected_option_index(option), was_waiting(false) {}

        void execute(core::GameState& state) override;
        void invert(core::GameState& state) override;
        CommandType get_type() const override { return CommandType::DECIDE; }
    };

}
