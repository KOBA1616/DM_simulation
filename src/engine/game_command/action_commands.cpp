#include "action_commands.hpp"
#include "engine/systems/game_logic_system.hpp"
#include "engine/systems/card/card_registry.hpp"
#include "commands.hpp" // For TransitionCommand

namespace dm::engine::game_command {

    using namespace dm::engine::systems;

    void PlayCardCommand::execute(core::GameState& state) {
        // Construct Instruction/Action to pass to GameLogicSystem
        // We use dispatch_action or handle_play_card directly

        // We need card_db. Using Global Registry for now as GameState doesn't own it.
        // This is a known architectural pattern in this project.
        const auto& card_db = CardRegistry::get_all_definitions();

        core::Action action;
        action.type = core::PlayerIntent::PLAY_CARD;
        action.source_instance_id = card_instance_id;
        action.spawn_source = spawn_source;
        action.is_spell_side = is_spell_side;

        // We use resolve_action_oneshot to execute it immediately using a temporary pipeline
        // This will push sub-commands to state history
        GameLogicSystem::resolve_action_oneshot(state, action, card_db);
    }

    void PlayCardCommand::invert(core::GameState& state) {
        // No-op: The sub-commands generated by execute() are in the history
        // and will be undone individually. This command serves as a marker/grouper.
        (void)state;
    }

    void AttackCommand::execute(core::GameState& state) {
        const auto& card_db = CardRegistry::get_all_definitions();

        core::Action action;
        if (target_id == -1) {
            action.type = core::PlayerIntent::ATTACK_PLAYER;
            action.target_player = target_player_id;
        } else {
            action.type = core::PlayerIntent::ATTACK_CREATURE;
            action.target_instance_id = target_id;
        }
        action.source_instance_id = source_id;

        GameLogicSystem::resolve_action_oneshot(state, action, card_db);
    }

    void AttackCommand::invert(core::GameState& state) {
        (void)state;
    }

    void BlockCommand::execute(core::GameState& state) {
        const auto& card_db = CardRegistry::get_all_definitions();

        core::Action action;
        action.type = core::PlayerIntent::BLOCK;
        action.source_instance_id = blocker_id;

        GameLogicSystem::resolve_action_oneshot(state, action, card_db);
    }

    void BlockCommand::invert(core::GameState& state) {
        (void)state;
    }

    void UseAbilityCommand::execute(core::GameState& state) {
        const auto& card_db = CardRegistry::get_all_definitions();

        core::Action action;
        action.type = core::PlayerIntent::USE_ABILITY;
        action.source_instance_id = source_id;
        action.target_instance_id = target_id;

        GameLogicSystem::resolve_action_oneshot(state, action, card_db);
    }

    void UseAbilityCommand::invert(core::GameState& state) {
        (void)state;
    }

    void ManaChargeCommand::execute(core::GameState& state) {
        // Mana Charge is just a Transition, but we can use the logic system to handle triggers/events if any
        // or just direct transition.
        const auto& card_db = CardRegistry::get_all_definitions();

        core::Action action;
        action.type = core::PlayerIntent::MANA_CHARGE;
        action.source_instance_id = card_id;

        GameLogicSystem::resolve_action_oneshot(state, action, card_db);
    }

    void ManaChargeCommand::invert(core::GameState& state) {
        (void)state;
    }

    void PassCommand::execute(core::GameState& state) {
        const auto& card_db = CardRegistry::get_all_definitions();
        core::Action action;
        action.type = core::PlayerIntent::PASS;

        GameLogicSystem::resolve_action_oneshot(state, action, card_db);
    }

    void PassCommand::invert(core::GameState& state) {
        // Pass triggers phase change, which is a FlowCommand.
        // So no-op here.
        (void)state;
    }

}
