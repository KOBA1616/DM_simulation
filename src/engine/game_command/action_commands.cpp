#include "action_commands.hpp"
#include "engine/systems/game_logic_system.hpp"
#include "engine/systems/card/card_registry.hpp"
#include "commands.hpp" // For TransitionCommand
#include <fstream>  // For debug logging

namespace dm::engine::game_command {

    using namespace dm::engine::systems;

    void PlayCardCommand::execute(core::GameState& state) {
        // Construct Instruction/Action to pass to GameLogicSystem
        // We use dispatch_action or handle_play_card directly

        // We need card_db. Using Global Registry for now as GameState doesn't own it.
        // This is a known architectural pattern in this project.
        const auto& card_db = CardRegistry::get_all_definitions();

        core::Action action;
        action.type = core::PlayerIntent::PLAY_CARD;
        action.source_instance_id = card_instance_id;
        action.spawn_source = spawn_source;
        action.is_spell_side = is_spell_side;

        // We use resolve_action_oneshot to execute it immediately using a temporary pipeline
        // This will push sub-commands to state history
        GameLogicSystem::resolve_action_oneshot(state, action, card_db);
    }

    void PlayCardCommand::invert(core::GameState& state) {
        // No-op: The sub-commands generated by execute() are in the history
        // and will be undone individually. This command serves as a marker/grouper.
        (void)state;
    }

    void AttackCommand::execute(core::GameState& state) {
        const auto& card_db = CardRegistry::get_all_definitions();

        core::Action action;
        if (target_id == -1) {
            action.type = core::PlayerIntent::ATTACK_PLAYER;
            action.target_player = target_player_id;
        } else {
            action.type = core::PlayerIntent::ATTACK_CREATURE;
            action.target_instance_id = target_id;
        }
        action.source_instance_id = source_id;

        GameLogicSystem::resolve_action_oneshot(state, action, card_db);
    }

    void AttackCommand::invert(core::GameState& state) {
        (void)state;
    }

    void BlockCommand::execute(core::GameState& state) {
        const auto& card_db = CardRegistry::get_all_definitions();

        core::Action action;
        action.type = core::PlayerIntent::BLOCK;
        action.source_instance_id = blocker_id;

        GameLogicSystem::resolve_action_oneshot(state, action, card_db);
    }

    void BlockCommand::invert(core::GameState& state) {
        (void)state;
    }

    void UseAbilityCommand::execute(core::GameState& state) {
        const auto& card_db = CardRegistry::get_all_definitions();

        core::Action action;
        action.type = core::PlayerIntent::USE_ABILITY;
        action.source_instance_id = source_id;
        action.target_instance_id = target_id;

        GameLogicSystem::resolve_action_oneshot(state, action, card_db);
    }

    void UseAbilityCommand::invert(core::GameState& state) {
        (void)state;
    }

    void ManaChargeCommand::execute(core::GameState& state) {
        using namespace dm::core;
        
        // Log for debugging - FIRST THING
        try {
            std::ofstream lout("logs/manacharge_trace.txt", std::ios::app);
            if (lout) {
                lout << "MANA_CHARGE_CMD CALLED id=" << card_id << "\n";
                lout.close();
            }
        } catch(...) {}
        
        // Direct card transition from Hand to Mana Zone
        // Find card location first
        const CardInstance* card_ptr = state.get_card_instance(card_id);
        if (!card_ptr) {
            try {
                std::ofstream lout("logs/manacharge_trace.txt", std::ios::app);
                if (lout) {
                    lout << "MANA_CHARGE_CMD ERROR: card_ptr is null for id=" << card_id << "\n";
                    lout.close();
                }
            } catch(...) {}
            return;
        }

        PlayerID owner = card_ptr->owner;
        Zone from_zone = Zone::GRAVEYARD;
        bool found = false;
        
        const Player& p = state.players[owner];
        for(const auto& c : p.hand) {
            if(c.instance_id == card_id) {
                from_zone = Zone::HAND;
                found = true;
                break;
            }
        }
        
        if (!found) {
            // Card not in hand, cannot mana charge
            return;
        }

        // Execute card move from Hand to Mana Zone
        auto move_cmd = std::make_shared<TransitionCommand>(card_id, Zone::HAND, Zone::MANA, owner);
        state.execute_command(std::move(move_cmd));
        
        // DM Rule: Mark that mana was charged this turn (max 1 per turn)
        // Use FlowCommand for proper undo support
        auto flow_cmd = std::make_shared<FlowCommand>(FlowCommand::FlowType::SET_MANA_CHARGED, 1);
        state.execute_command(std::move(flow_cmd));
        
        // Log for debugging
        try {
            std::ofstream lout("logs/pipeline_trace.txt", std::ios::app);
            if (lout) {
                lout << "MANA_CHARGE_CMD id=" << card_id
                     << " owner=" << owner
                     << " result=success, set mana_charged_this_turn=true via FlowCommand\n";
                lout.close();
            }
        } catch(...) {}
    }

    void ManaChargeCommand::invert(core::GameState& state) {
        (void)state;
    }

    void PassCommand::execute(core::GameState& state) {
        const auto& card_db = CardRegistry::get_all_definitions();
        core::Action action;
        action.type = core::PlayerIntent::PASS;

        GameLogicSystem::resolve_action_oneshot(state, action, card_db);
    }

    void PassCommand::invert(core::GameState& state) {
        // Pass triggers phase change, which is a FlowCommand.
        // So no-op here.
        (void)state;
    }

}
