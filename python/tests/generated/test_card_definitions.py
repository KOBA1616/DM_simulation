# This file is automatically generated by scripts/generate_card_tests.py
# Do not edit directly.

import unittest
from pathlib import Path
import json

class TestCardDefinitions(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        # Locate cards.json relative to this test file
        # This test file is in python/tests/generated/
        # Root is ../../../
        root_dir = Path(__file__).resolve().parent.parent.parent.parent
        cards_path = root_dir / 'data' / 'cards.json'
        if not cards_path.exists():
             # Fallback if running from root
             cards_path = Path('data/cards.json')
        with open(cards_path, 'r', encoding='utf-8') as f:
            cls.cards = {c['id']: c for c in json.load(f)}

    def test_card_1_月光電人オボロカゲロウ(self):
        card = self.cards[1]
        self._validate_card_structure(card)
        self._validate_card_logic(card)

    def test_card_2_芸魔隠狐カラクリバーシ(self):
        card = self.cards[2]
        self._validate_card_structure(card)
        self._validate_card_logic(card)

    def test_card_3_芸魔王将カクメイジン(self):
        card = self.cards[3]
        self._validate_card_structure(card)
        self._validate_card_logic(card)

    def test_card_4_Napo獅子_Vi無粋(self):
        card = self.cards[4]
        self._validate_card_structure(card)
        self._validate_card_logic(card)

    def test_card_5_AQvibrato(self):
        card = self.cards[5]
        self._validate_card_structure(card)
        self._validate_card_logic(card)

    def test_card_6_歌舞音愛_ヒメカット(self):
        card = self.cards[6]
        self._validate_card_structure(card)
        self._validate_card_logic(card)

    def test_card_7_氷柱と炎弧の決断(self):
        card = self.cards[7]
        self._validate_card_structure(card)
        self._validate_card_logic(card)

    def test_card_8_同期の妖精(self):
        card = self.cards[8]
        self._validate_card_structure(card)
        self._validate_card_logic(card)

    def test_card_9_ボン_キゴマイム(self):
        card = self.cards[9]
        self._validate_card_structure(card)
        self._validate_card_logic(card)

    def test_card_10_瞬閃と疾駆と双撃の決断(self):
        card = self.cards[10]
        self._validate_card_structure(card)
        self._validate_card_logic(card)

    def test_card_11__立ち上がる_悪魔に天使落ちるかな(self):
        card = self.cards[11]
        self._validate_card_structure(card)
        self._validate_card_logic(card)

    def test_card_12_ストリーミング_シェイパー(self):
        card = self.cards[12]
        self._validate_card_structure(card)
        self._validate_card_logic(card)

    def test_card_13_単騎連射_マグナム(self):
        card = self.cards[13]
        self._validate_card_structure(card)
        self._validate_card_logic(card)

    def test_card_14_精霊王の聖典(self):
        card = self.cards[14]
        self._validate_card_structure(card)
        self._validate_card_logic(card)

    def _validate_card_structure(self, card):
        self.assertIn('id', card)
        self.assertIn('name', card)
        self.assertIn('type', card)
        self.assertIn('civilizations', card)
        self.assertIn('cost', card)
        # Edge case checks
        self.assertGreaterEqual(card.get('cost', 0), 0, 'Cost must be non-negative')
        if card['type'] == 'CREATURE':
            self.assertIn('power', card)
            self.assertGreaterEqual(card.get('power', 0), 0, 'Power must be non-negative')
            self.assertIn('races', card)

    def _validate_card_logic(self, card):
        if 'effects' in card:
            for effect in card['effects']:
                self._validate_effect_variable_flow(effect)
        if 'spell_side' in card:
            self._validate_card_structure(card['spell_side'])
            self._validate_card_logic(card['spell_side'])

    def _validate_effect_variable_flow(self, effect):
        if 'commands' not in effect:
            return
        available_keys = set()
        self._validate_commands(effect['commands'], available_keys)

    def _validate_commands(self, commands, available_keys):
        # We copy keys to simulate scope if needed
        current_keys = set(available_keys)
        for cmd in commands:
            if 'input_value_key' in cmd and cmd['input_value_key']:
                key = cmd['input_value_key']
                if key not in current_keys and not self._is_implicit_key(key):
                     # Fail if key is missing and not implicit
                     self.fail(f'Variable {key} used in command {cmd.get("type")} but not produced by previous commands in scope.')
            if 'output_value_key' in cmd and cmd['output_value_key']:
                current_keys.add(cmd['output_value_key'])

            # Handle nested commands
            if cmd.get('type') == 'IF':
                if 'if_true' in cmd:
                    self._validate_commands(cmd['if_true'], current_keys)
                if 'if_false' in cmd:
                    self._validate_commands(cmd['if_false'], current_keys)
            if cmd.get('type') == 'SELECT_OPTION':
                if 'options' in cmd:
                    for option in cmd['options']:
                         self._validate_commands(option, current_keys)

    def _is_implicit_key(self, key):
        # List of keys provided by the engine context or event triggers
        known_implicits = {'EVENT_SOURCE', 'MANA_CIVILIZATION_COUNT'}
        return key in known_implicits
