import json
import os
import sys
from typing import Dict, List, Set, Any, Optional
from dataclasses import dataclass
from enum import Enum

class ValidatorError(Exception):
    pass

@dataclass
class ValidationResult:
    card_id: int
    card_name: str
    errors: List[str]
    warnings: List[str]
    is_valid: bool

class CardValidator:
    def __init__(self):
        self.known_zones = {
            "BATTLE_ZONE", "MANA_ZONE", "GRAVEYARD", "HAND", "DECK", "SHIELD_ZONE",
            "EFFECT_BUFFER", # Implied by EffectPrimitive
            "NONE", "DECK_BOTTOM", "DECK_TOP"
        }
        self.known_command_types = {
            "NONE", "TRANSITION", "MUTATE", "FLOW", "QUERY",
            "DRAW_CARD", "DISCARD", "DESTROY", "BOOST_MANA", "TAP", "UNTAP",
            "POWER_MOD", "ADD_KEYWORD", "RETURN_TO_HAND", "BREAK_SHIELD",
            "SEARCH_DECK", "SHIELD_TRIGGER",
            "MOVE_CARD", "ADD_MANA", "SEND_TO_MANA", "PLAYER_MANA_CHARGE",
            "SEARCH_DECK_BOTTOM", "ADD_SHIELD", "SEND_TO_DECK_BOTTOM",
            "ATTACK_PLAYER", "ATTACK_CREATURE", "BLOCK", "RESOLVE_BATTLE",
            "RESOLVE_PLAY", "RESOLVE_EFFECT", "SHUFFLE_DECK", "LOOK_AND_ADD",
            "MEKRAID", "REVEAL_CARDS", "PLAY_FROM_ZONE", "CAST_SPELL",
            "SUMMON_TOKEN", "SHIELD_BURN", "SELECT_NUMBER", "CHOICE",
            "LOOK_TO_BUFFER", "SELECT_FROM_BUFFER", "PLAY_FROM_BUFFER",
            "MOVE_BUFFER_TO_ZONE", "FRIEND_BURST", "REGISTER_DELAYED_EFFECT",
            "IF", "IF_ELSE", "ELSE"
        }
        # Variables that are implicitly available or generated by system
        self.global_vars = {"MANA_CIVILIZATIONS", "SHIELD_COUNT", "TURN_NUMBER"}

    def validate_file(self, filepath: str) -> List[ValidationResult]:
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                data = json.load(f)
        except Exception as e:
            return [ValidationResult(0, "File Error", [f"Failed to load JSON: {str(e)}"], [], False)]

        results = []
        if isinstance(data, list):
            for card in data:
                results.append(self.validate_card(card))
        elif isinstance(data, dict):
             # Might be single card or wrapped
             if "id" in data:
                 results.append(self.validate_card(data))
             else:
                 # Should not happen based on current cards.json structure
                 pass

        return results

    def validate_card(self, card_data: Dict[str, Any]) -> ValidationResult:
        errors = []
        warnings = []
        card_id = card_data.get("id", 0)
        card_name = card_data.get("name", "Unknown")

        # 1. Structure Check
        required_fields = ["id", "name", "civilizations", "type", "cost"]
        for field in required_fields:
            if field not in card_data:
                errors.append(f"Missing required field: {field}")

        # 2. Effects/Triggers Validation
        # Check 'triggers' list
        if "triggers" in card_data:
            for idx, effect in enumerate(card_data["triggers"]):
                effect_errors = self.validate_effect_def(effect, f"Trigger[{idx}]")
                errors.extend(effect_errors)

        # Check 'effects' list (passive abilities or legacy trigger mapping)
        if "effects" in card_data:
             for idx, effect in enumerate(card_data["effects"]):
                effect_errors = self.validate_effect_def(effect, f"Effect[{idx}]")
                errors.extend(effect_errors)

        # 3. Spell Side Validation
        if "spell_side" in card_data and card_data["spell_side"]:
             spell_result = self.validate_card(card_data["spell_side"])
             if not spell_result.is_valid:
                 errors.extend([f"Spell Side: {e}" for e in spell_result.errors])
                 warnings.extend([f"Spell Side: {w}" for w in spell_result.warnings])

        return ValidationResult(card_id, card_name, errors, warnings, len(errors) == 0)

    def validate_effect_def(self, effect: Dict[str, Any], context_prefix: str) -> List[str]:
        commands = effect.get("commands", [])
        # Start validation with a fresh copy of global variables
        available_vars = self.global_vars.copy()
        return self.validate_command_list(commands, context_prefix, available_vars)

    def validate_command_list(self, commands: List[Dict[str, Any]], context_prefix: str, available_vars: Set[str]) -> List[str]:
        errors = []

        for cmd_idx, cmd in enumerate(commands):
            cmd_context = f"{context_prefix} Command[{cmd_idx}]"

            # Type check
            cmd_type = cmd.get("type", "NONE")
            if cmd_type not in self.known_command_types:
                errors.append(f"{cmd_context}: Unknown command type '{cmd_type}'")

            # Zone checks
            from_zone = cmd.get("from_zone")
            if from_zone and from_zone not in self.known_zones:
                 errors.append(f"{cmd_context}: Unknown from_zone '{from_zone}'")

            to_zone = cmd.get("to_zone")
            if to_zone and to_zone not in self.known_zones:
                 errors.append(f"{cmd_context}: Unknown to_zone '{to_zone}'")

            # Variable References
            input_key = cmd.get("input_value_key")
            output_key = cmd.get("output_value_key")

            if input_key:
                if input_key not in available_vars:
                    errors.append(f"{cmd_context}: Reference to undefined variable '{input_key}'")

            if output_key:
                available_vars.add(output_key)

            # Recursive validation for nested commands
            if "if_true" in cmd:
                 # Nested block inherits current vars.
                 # Changes inside block (new vars) usually don't leak out in strict scoping,
                 # but for simplicity and typical usage here, we might allow leakage or assume block scope.
                 # Let's assume block scope: vars defined inside are NOT available after the block.
                 nested_vars = available_vars.copy()
                 errors.extend(self.validate_command_list(cmd["if_true"], f"{cmd_context}.if_true", nested_vars))

            if "if_false" in cmd:
                 nested_vars = available_vars.copy()
                 errors.extend(self.validate_command_list(cmd["if_false"], f"{cmd_context}.if_false", nested_vars))

        return errors

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="Validate Card JSON definitions")
    parser.add_argument("filepath", help="Path to cards.json")
    args = parser.parse_args()

    validator = CardValidator()
    results = validator.validate_file(args.filepath)

    failed_count = 0
    for res in results:
        if not res.is_valid:
            print(f"FAIL: [{res.card_id}] {res.card_name}")
            for err in res.errors:
                print(f"  - {err}")
            failed_count += 1
        elif res.warnings:
            print(f"WARN: [{res.card_id}] {res.card_name}")
            for warn in res.warnings:
                print(f"  - {warn}")

    print(f"\nValidation Complete. {len(results)} cards processed. {failed_count} failures.")
    if failed_count > 0:
        sys.exit(1)
