# -*- coding: utf-8 -*-
from PyQt6.QtWidgets import QWidget, QFormLayout, QComboBox, QLabel, QLineEdit
from PyQt6.QtCore import pyqtSignal, Qt
from dm_toolkit.gui.localization import tr
from dm_toolkit.gui.editor.variable_link_manager import VariableLinkManager

class VariableLinkWidget(QWidget):
    """
    Reusable widget for linking variables (Action Chaining).
    Handles 'Input Source' selection (Manual, Event Source, Previous Steps) and Output Key generation.
    """

    # Signal emitted when any property changes
    linkChanged = pyqtSignal()
    # Signal emitted when smart link state changes (to update parent visibility)
    smartLinkStateChanged = pyqtSignal(bool)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.current_item = None
        self.setup_ui()

    def setup_ui(self):
        layout = QFormLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        self.input_key_combo = QComboBox()
        self.input_key_combo.setEditable(False)
        self.input_key_label = QLabel(tr("Input Source"))
        layout.addRow(self.input_key_label, self.input_key_combo)

        self.output_key_label = QLabel(tr("Output Key"))
        self.output_key_edit = QLineEdit()
        layout.addRow(self.output_key_label, self.output_key_edit)
        self.output_key_label.setVisible(False)
        self.output_key_edit.setVisible(False)
        # Track whether the current output key was auto-generated
        self._output_autogenerated = False

        # If user edits the output key, mark it as manually edited (not autogenerated)
        self.output_key_edit.textEdited.connect(self._on_output_edited)

        # Connect signals
        self.input_key_combo.currentIndexChanged.connect(self.on_combo_changed)
        self.output_key_edit.textChanged.connect(self.linkChanged.emit)

        # Initial Population
        self.populate_input_keys()

    def set_current_item(self, item):
        self.current_item = item

        # Update Input Label using Manager
        action_data = item.data(Qt.ItemDataRole.UserRole + 2)
        if action_data:
            act_type = action_data.get('type')
            self.input_key_label.setText(VariableLinkManager.get_input_label(act_type))
        else:
            self.input_key_label.setText(tr("Input Source"))

        self.populate_input_keys()

    def on_combo_changed(self):
        self.linkChanged.emit()
        self.smartLinkStateChanged.emit(self.is_smart_link_active())

    def set_data(self, data):
        self.blockSignals(True)

        input_key = data.get('input_value_key', '')
        out_val = data.get('output_value_key', '')
        self.output_key_edit.setText(out_val)
        # Show output widgets if there is an output key present
        self._update_output_visibility()

        self.populate_input_keys()

        # Match key
        found = False
        # Try to find exact match
        for i in range(self.input_key_combo.count()):
             if self.input_key_combo.itemData(i) == input_key:
                  self.input_key_combo.setCurrentIndex(i)
                  found = True
                  break

        # If not found and not empty, it might be a custom key from JSON
        # If it's manual (empty), index 0 is already Manual
        if not found and input_key:
             # Add it temporarily so we don't lose data
             self.input_key_combo.addItem(f"{input_key} (Unknown)", input_key)
             self.input_key_combo.setCurrentIndex(self.input_key_combo.count()-1)
        elif not found and not input_key:
             self.input_key_combo.setCurrentIndex(0) # Manual Input

        self.blockSignals(False)
        # Emit state change to ensure parent UI updates (hiding val1 etc)
        self.smartLinkStateChanged.emit(self.is_smart_link_active())

    def get_data(self, data):
        """
        Updates the data dictionary in-place.
        """
        # Input Key
        idx = self.input_key_combo.currentIndex()
        val = ""
        if idx >= 0:
             val = self.input_key_combo.itemData(idx)
             if val is None: val = "" # Safety

        data['input_value_key'] = val

        # Output Key
        data['output_value_key'] = self.output_key_edit.text()
        # Also preserve flag if it was autogenerated (for UI/metadata use)
        if self._output_autogenerated:
            data['_output_autogenerated'] = True

    def ensure_output_key(self, action_type, produces_output):
        """
        Generates output key if missing and required.
        Uses VariableLinkManager for key generation.
        """
        if produces_output and not self.output_key_edit.text() and self.current_item:
             new_key = VariableLinkManager.generate_output_key(self.current_item, action_type)

             self.output_key_edit.setText(new_key)
             # Mark as autogenerated and give a tooltip so user knows
             self._output_autogenerated = True
             self.output_key_edit.setToolTip(tr("自動生成された出力キー。編集すると自動生成フラグが解除されます。"))
             self._update_output_visibility()
             # This triggers textChanged -> linkChanged

    def populate_input_keys(self):
        current_data = self.input_key_combo.currentData()
        self.input_key_combo.clear()

        # Use Manager to get variables
        variables = VariableLinkManager.get_available_variables(self.current_item)

        for label, key in variables:
            self.input_key_combo.addItem(label, key)

        # Try to restore selection if possible
        if current_data is not None:
             for i in range(self.input_key_combo.count()):
                  if self.input_key_combo.itemData(i) == current_data:
                       self.input_key_combo.setCurrentIndex(i)
                       break

    def _on_output_edited(self, text: str):
        """Called when user edits the output key manually."""
        # If previously autogenerated, clear that state
        if self._output_autogenerated:
            self._output_autogenerated = False
            self.output_key_edit.setToolTip("")
        # Ensure the widget remains visible when user types
        self._update_output_visibility()

    def _update_output_visibility(self):
        """Show/hide the output key controls based on current text or autogenerated state."""
        has_text = bool(self.output_key_edit.text())
        # Show when there is a value or it was autogenerated
        show = has_text or self._output_autogenerated
        self.output_key_label.setVisible(show)
        self.output_key_edit.setVisible(show)

    def is_smart_link_active(self):
        # Active if selected item data is not empty string
        idx = self.input_key_combo.currentIndex()
        if idx < 0: return False
        data = self.input_key_combo.itemData(idx)
        return bool(data)

    def set_smart_link_enabled(self, enabled):
        """
        Controls whether the input source can be changed.
        If disabled, force Manual Input? Or just hide?
        Usually this is called to enable/disable the 'feature'.
        If 'enabled' is False, it means this action does not support input linking or Val1 is hidden.
        """
        # Ensure we pass a boolean to setVisible — callers may pass None
        self.setVisible(bool(enabled))
