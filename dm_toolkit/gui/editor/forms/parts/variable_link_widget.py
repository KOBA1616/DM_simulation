# -*- coding: utf-8 -*-
from PyQt6.QtWidgets import QWidget, QFormLayout, QComboBox, QLabel, QLineEdit
from PyQt6.QtCore import pyqtSignal, Qt
from dm_toolkit.gui.localization import tr
from dm_toolkit.gui.editor.variable_link_manager import VariableLinkManager

class VariableLinkWidget(QWidget):
    """
    Reusable widget for linking variables (Action Chaining).
    Handles 'Input Source' selection (Manual, Event Source, Previous Steps) and Output Key generation.
    Also allows specifying how the linked input is used (e.g., Cost, Amount, Selection Count).
    """

    # Signal emitted when any property changes
    linkChanged = pyqtSignal()
    # Signal emitted when smart link state changes (to update parent visibility)
    smartLinkStateChanged = pyqtSignal(bool)

    def __init__(self, parent=None):
        super().__init__(parent)
        self.current_item = None
        self.setup_ui()

    def setup_ui(self):
        layout = QFormLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        # Input Source (previous output or reserved variables)
        self.input_key_combo = QComboBox()
        self.input_key_combo.setEditable(False)
        self.input_key_label = QLabel(tr("Input Source"))
        layout.addRow(self.input_key_label, self.input_key_combo)

        # Input Usage (how to use linked value)
        self.input_usage_combo = QComboBox()
        self.input_usage_combo.setEditable(False)
        self.input_usage_label = QLabel(tr("Input Usage"))
        # Provide common usage mappings
        usage_items = [
            (tr("Default"), ""),
            (tr("Cost"), "COST"),
            (tr("Max Cost"), "MAX_COST"),
            (tr("Min Cost"), "MIN_COST"),
            (tr("Amount"), "AMOUNT"),
            (tr("Selection Count"), "SELECTION"),
            (tr("Target Count"), "TARGET_COUNT"),
            (tr("Power"), "POWER"),
            (tr("Max Power"), "MAX_POWER"),
            (tr("Min Power"), "MIN_POWER"),
        ]
        for label, key in usage_items:
            self.input_usage_combo.addItem(label, key)
        layout.addRow(self.input_usage_label, self.input_usage_combo)

        # Output Key (variable produced by this step)
        self.output_key_label = QLabel(tr("Output Key"))
        self.output_key_edit = QLineEdit()
        layout.addRow(self.output_key_label, self.output_key_edit)
        self.output_key_label.setVisible(False)
        self.output_key_edit.setVisible(False)
        # Track whether the current output key was auto-generated
        self._output_autogenerated = False

        # If user edits the output key, mark it as manually edited (not autogenerated)
        self.output_key_edit.textEdited.connect(self._on_output_edited)

        # Connect signals
        self.input_key_combo.currentIndexChanged.connect(self.on_combo_changed)
        self.input_usage_combo.currentIndexChanged.connect(self.linkChanged.emit)
        self.output_key_edit.textChanged.connect(self.linkChanged.emit)

        # Initial visibility (hide usage until input is linked)
        self.input_usage_label.setVisible(False)
        self.input_usage_combo.setVisible(False)

        # Initial Population
        self.populate_input_keys()

    def set_current_item(self, item):
        self.current_item = item

        # Update Input Label using Manager
        action_data = item.data(Qt.ItemDataRole.UserRole + 2)
        if action_data:
            act_type = action_data.get('type')
            self.input_key_label.setText(VariableLinkManager.get_input_label(act_type))
        else:
            self.input_key_label.setText(tr("Input Source"))

        self.populate_input_keys()

    def on_combo_changed(self):
        # Update Input Usage visibility based on whether input is linked
        is_linked = self.is_smart_link_active()
        self.input_usage_label.setVisible(is_linked)
        self.input_usage_combo.setVisible(is_linked)
        
        self.linkChanged.emit()
        self.smartLinkStateChanged.emit(is_linked)

    def set_data(self, data):
        self.blockSignals(True)

        input_key = data.get('input_value_key', '')
        input_usage = data.get('input_value_usage', '')
        out_val = data.get('output_value_key', '')
        self.output_key_edit.setText(out_val)
        # Show output widgets if there is an output key present
        self._update_output_visibility()

        self.populate_input_keys()

        # Match key
        found = False
        # Try to find exact match
        for i in range(self.input_key_combo.count()):
             if self.input_key_combo.itemData(i) == input_key:
                  self.input_key_combo.setCurrentIndex(i)
                  found = True
                  break

        # If not found and not empty, it might be a custom key from JSON
        # If it's manual (empty), index 0 is already Manual
        if not found and input_key:
             # Try to recover label from metadata
             saved_label = data.get('_input_value_label', '')
             if saved_label:
                 label = f"{saved_label} ({tr('Missing')})"
             else:
                 label = f"{input_key} ({tr('Unknown')})"

             # Add it temporarily so we don't lose data
             self.input_key_combo.addItem(label, input_key)
             self.input_key_combo.setCurrentIndex(self.input_key_combo.count()-1)
        elif not found and not input_key:
             self.input_key_combo.setCurrentIndex(0) # Manual Input

        # Set usage selection
        # Try exact match of data key
        usage_found = False
        for i in range(self.input_usage_combo.count()):
            if self.input_usage_combo.itemData(i) == input_usage:
                self.input_usage_combo.setCurrentIndex(i)
                usage_found = True
                break
        if not usage_found:
            # Default to first (empty) option
            self.input_usage_combo.setCurrentIndex(0)

        # Update Input Usage visibility
        is_linked = self.is_smart_link_active()
        self.input_usage_label.setVisible(is_linked)
        self.input_usage_combo.setVisible(is_linked)
        
        self.blockSignals(False)
        # Emit state change to ensure parent UI updates (hiding val1 etc)
        self.smartLinkStateChanged.emit(is_linked)

    def get_data(self, data):
        """
        Updates the data dictionary in-place.
        """
        # Input Key
        idx = self.input_key_combo.currentIndex()
        val = ""
        if idx >= 0:
             val = self.input_key_combo.itemData(idx)
             if val is None: val = "" # Safety

        data['input_value_key'] = val

        # Save friendly label if valid link
        if val and val in getattr(self, 'valid_keys', set()):
             data['_input_value_label'] = self.input_key_combo.currentText()

        # Input Usage
        uidx = self.input_usage_combo.currentIndex()
        usage_val = ""
        if uidx >= 0:
            usage_val = self.input_usage_combo.itemData(uidx)
            if usage_val is None:
                usage_val = ""
        data['input_value_usage'] = usage_val

        # Output Key
        data['output_value_key'] = self.output_key_edit.text()
        # Also preserve flag if it was autogenerated (for UI/metadata use)
        if self._output_autogenerated:
            data['_output_autogenerated'] = True

    def ensure_output_key(self, action_type, produces_output):
        """
        Generates output key if missing and required.
        Uses VariableLinkManager for key generation.
        """
        if produces_output and not self.output_key_edit.text() and self.current_item:
             new_key = VariableLinkManager.generate_output_key(self.current_item, action_type)

             self.output_key_edit.setText(new_key)
             # Mark as autogenerated and give a tooltip so user knows
             self._output_autogenerated = True
             self.output_key_edit.setToolTip(tr("Auto-generated output key. Editing removes the auto-generation flag."))
             self._update_output_visibility()
             # This triggers textChanged -> linkChanged

    def populate_input_keys(self):
        current_data = self.input_key_combo.currentData()
        self.input_key_combo.clear()
        self.valid_keys = set() # New set to track valid keys

        # Use Manager to get variables
        variables = VariableLinkManager.get_available_variables(self.current_item)

        for label, key in variables:
            self.input_key_combo.addItem(label, key)
            self.valid_keys.add(key)

        # Try to restore selection if possible
        if current_data is not None:
             for i in range(self.input_key_combo.count()):
                  if self.input_key_combo.itemData(i) == current_data:
                       self.input_key_combo.setCurrentIndex(i)
                       break

    def _on_output_edited(self, text: str):
        """Called when user edits the output key manually."""
        # If previously autogenerated, clear that state
        if self._output_autogenerated:
            self._output_autogenerated = False
            self.output_key_edit.setToolTip("")
        # Ensure the widget remains visible when user types
        self._update_output_visibility()

    def _update_output_visibility(self):
        """Show/hide the output key controls based on current text or autogenerated state."""
        has_text = bool(self.output_key_edit.text())
        # Show when there is a value or it was autogenerated
        show = has_text or self._output_autogenerated
        self.output_key_label.setVisible(show)
        self.output_key_edit.setVisible(show)

    def is_smart_link_active(self):
        # Active if selected item data is not empty string
        idx = self.input_key_combo.currentIndex()
        if idx < 0: return False
        data = self.input_key_combo.itemData(idx)
        return bool(data)

    def set_smart_link_enabled(self, enabled):
        """
        Controls whether the input source can be changed.
        If disabled, force Manual Input? Or just hide?
        Usually this is called to enable/disable the 'feature'.
        If 'enabled' is False, it means this action does not support input linking or Val1 is hidden.
        """
        # Ensure we pass a boolean to setVisible â€” callers may pass None
        self.setVisible(bool(enabled))

    def set_output_hint(self, produces_output):
        """
        Enables/disables output key UI based on whether the command produces output.
        If produces_output is True, show output_key_edit; otherwise hide if empty.
        """
        if produces_output:
            # Force show output key controls when command produces output
            self.output_key_label.setVisible(True)
            self.output_key_edit.setVisible(True)
        else:
            # Hide if no output expected and field is empty
            self._update_output_visibility()

    @property
    def output_label_text(self):
        return self.output_key_label.text()

    @output_label_text.setter
    def output_label_text(self, text):
        self.output_key_label.setText(text)
