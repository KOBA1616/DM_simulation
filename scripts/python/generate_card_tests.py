import json
import os
import sys
import unittest
from pathlib import Path

# Add project root to path
PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
sys.path.append(str(PROJECT_ROOT))

# Attempt to import GameInstance/CardDatabase from dm_ai_module
# If unavailable, these tests will fail or be skipped depending on logic below.
# But dm_ai_module.py shim should exist.
try:
    from dm_ai_module import GameInstance, CardDatabase
except ImportError:
    GameInstance = None
    CardDatabase = None

class AutoGeneratedCardTest(unittest.TestCase):
    """
    Base class for auto-generated card tests.
    """
    card_db = None

    @classmethod
    def setUpClass(cls):
        if not GameInstance or not CardDatabase:
            raise unittest.SkipTest("dm_ai_module not available")

        # Load card database
        cls.card_db = CardDatabase()
        # Ensure we can load cards.json
        cards_path = PROJECT_ROOT / "data" / "cards.json"
        if not cards_path.exists():
            raise FileNotFoundError(f"cards.json not found at {cards_path}")

        # We might want to load the json manually to iterate keys if needed,
        # but CardDatabase should handle it.
        # Assuming we need list of IDs to generate tests:
        with open(cards_path, "r", encoding="utf-8") as f:
            cls.card_data_list = json.load(f)

    def setUp(self):
        self.game = GameInstance()
        self.game.initialize()
        self.player = self.game.player_instances[0]
        self.opponent = self.game.player_instances[1]

    def _test_card_load_and_play(self, card_id):
        """
        Generic test to verify a card can be loaded and played (basic mechanics).
        """
        # 1. Add card to hand (using GameState helper if available)
        # The shim has helper methods on GameState, accessible via self.game.state
        self.game.state.add_card_to_hand(0, card_id)

        hand_cards = self.player.hand
        self.assertTrue(len(hand_cards) > 0, f"Card {card_id} should be in hand")

        card_inst = hand_cards[-1]
        self.assertEqual(card_inst.card_id, card_id)

        # 2. Check if we can play it (mana cost check might fail if we don't cheat mana)
        # Cheat: Give infinite mana
        for _ in range(10):
            self.game.state.add_card_to_mana(0, card_id)
        for c in self.player.mana_zone:
            c.tapped = False

        # 3. Attempt to play
        # Identify card type to determine command
        card_def = self.card_db.get_card(card_id)
        if not card_def:
            self.fail(f"Card definition not found for {card_id}")

        # Basic play attempt
        try:
            cmd = {
                "type": "PLAY_CARD",
                "card_id": card_id,
                "source_instance_id": card_inst.instance_id,
                "target_player": 0
            }
            # Execute command using game instance wrapper
            # In stub, execute_action calls GenericCardSystem.resolve_action
            self.game.execute_action(cmd)

            # Note: We do not strictly verify "removed from hand" here because
            # the stub implementation logic for PLAY_CARD might be simple
            # and might not perfectly simulate every card type's zone transition
            # without full engine logic. The goal is to ensure NO CRASH.

        except Exception as e:
            self.fail(f"Exception during test execution for card {card_id}: {e}")

def create_test_method(card_id, card_name):
    def test_method(self):
        self._test_card_load_and_play(card_id)
    return test_method

# Dynamic generation at module level for pytest discovery
# We check if file exists and generate methods on the class
cards_path = PROJECT_ROOT / "data" / "cards.json"
if cards_path.exists():
    try:
        with open(cards_path, "r", encoding="utf-8") as f:
            cards_json = json.load(f)
            for card in cards_json:
                c_id = card.get("id")
                c_name = card.get("name", "Unknown")
                # Create safe name for python method
                safe_name = "".join(c for c in c_name if c.isalnum() or c == "_")
                if c_id is not None:
                    test_name = f"test_card_{c_id}_{safe_name}"
                    setattr(AutoGeneratedCardTest, test_name, create_test_method(c_id, c_name))
    except Exception:
        pass # If json load fails, we just don't generate tests (or let setUpClass fail)

if __name__ == "__main__":
    unittest.main()
