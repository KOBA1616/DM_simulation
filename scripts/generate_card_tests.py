import json
import os
import sys
from pathlib import Path

def main():
    # Locate data/cards.json
    # Assuming this script is in scripts/
    root_dir = Path(__file__).resolve().parent.parent
    cards_path = root_dir / 'data' / 'cards.json'

    if not cards_path.exists():
        print(f"Error: {cards_path} not found.")
        return

    with open(cards_path, 'r', encoding='utf-8') as f:
        cards = json.load(f)

    # Output file
    output_dir = root_dir / 'python' / 'tests' / 'generated'
    output_dir.mkdir(parents=True, exist_ok=True)
    output_file = output_dir / 'test_card_definitions.py'

    with open(output_file, 'w', encoding='utf-8') as f:
        # Write header
        f.write("# This file is automatically generated by scripts/generate_card_tests.py\n")
        f.write("# Do not edit directly.\n\n")
        f.write("import unittest\n")
        f.write("from pathlib import Path\n")
        f.write("import json\n\n")

        f.write("class TestCardDefinitions(unittest.TestCase):\n")
        f.write("    @classmethod\n")
        f.write("    def setUpClass(cls):\n")
        f.write("        # Locate cards.json relative to this test file\n")
        f.write("        # This test file is in python/tests/generated/\n")
        f.write("        # Root is ../../../\n")
        f.write("        root_dir = Path(__file__).resolve().parent.parent.parent.parent\n")
        f.write("        cards_path = root_dir / 'data' / 'cards.json'\n")
        f.write("        if not cards_path.exists():\n")
        f.write("             # Fallback if running from root\n")
        f.write("             cards_path = Path('data/cards.json')\n")
        f.write("        with open(cards_path, 'r', encoding='utf-8') as f:\n")
        f.write("            cls.cards = {c['id']: c for c in json.load(f)}\n\n")

        for card in cards:
            card_id = card.get('id', 'unknown')
            card_name = card.get('name', 'unknown')
            # Sanitize name for function name
            # Replace spaces and non-alphanumeric chars (except underscore)
            safe_name = "".join(c if c.isalnum() else "_" for c in card_name)
            # Ensure valid identifier (cannot start with number)
            if safe_name and safe_name[0].isdigit():
                safe_name = "_" + safe_name

            test_func_name = f"test_card_{card_id}_{safe_name}"

            f.write(f"    def {test_func_name}(self):\n")
            f.write(f"        card = self.cards[{card_id}]\n")
            f.write(f"        self._validate_card_structure(card)\n")
            f.write(f"        self._validate_card_logic(card)\n\n")

        # Add validation helper methods to the class
        f.write("    def _validate_card_structure(self, card):\n")
        f.write("        self.assertIn('id', card)\n")
        f.write("        self.assertIn('name', card)\n")
        f.write("        self.assertIn('type', card)\n")
        f.write("        self.assertIn('civilizations', card)\n")
        f.write("        self.assertIn('cost', card)\n")
        f.write("        # Edge case checks\n")
        f.write("        self.assertGreaterEqual(card.get('cost', 0), 0, 'Cost must be non-negative')\n")
        f.write("        if card['type'] == 'CREATURE':\n")
        f.write("            self.assertIn('power', card)\n")
        f.write("            self.assertGreaterEqual(card.get('power', 0), 0, 'Power must be non-negative')\n")
        f.write("            self.assertIn('races', card)\n")
        f.write("\n")

        f.write("    def _validate_card_logic(self, card):\n")
        f.write("        if 'effects' in card:\n")
        f.write("            for effect in card['effects']:\n")
        f.write("                self._validate_effect_variable_flow(effect)\n")
        f.write("        if 'spell_side' in card:\n")
        f.write("            self._validate_card_structure(card['spell_side'])\n")
        f.write("            self._validate_card_logic(card['spell_side'])\n")
        f.write("\n")

        f.write("    def _validate_effect_variable_flow(self, effect):\n")
        f.write("        if 'commands' not in effect:\n")
        f.write("            return\n")
        f.write("        available_keys = set()\n")
        f.write("        self._validate_commands(effect['commands'], available_keys)\n")
        f.write("\n")

        f.write("    def _validate_commands(self, commands, available_keys):\n")
        f.write("        # We copy keys to simulate scope if needed\n")
        f.write("        current_keys = set(available_keys)\n")
        f.write("        for cmd in commands:\n")
        f.write("            if 'input_value_key' in cmd and cmd['input_value_key']:\n")
        f.write("                key = cmd['input_value_key']\n")
        f.write("                if key not in current_keys and not self._is_implicit_key(key):\n")
        f.write("                     # Fail if key is missing and not implicit\n")
        f.write("                     self.fail(f'Variable {key} used in command {cmd.get(\"type\")} but not produced by previous commands in scope.')\n")
        f.write("            if 'output_value_key' in cmd and cmd['output_value_key']:\n")
        f.write("                current_keys.add(cmd['output_value_key'])\n")
        f.write("            \n")
        f.write("            # Handle nested commands\n")
        f.write("            if cmd.get('type') == 'IF':\n")
        f.write("                if 'if_true' in cmd:\n")
        f.write("                    self._validate_commands(cmd['if_true'], current_keys)\n")
        f.write("                if 'if_false' in cmd:\n")
        f.write("                    self._validate_commands(cmd['if_false'], current_keys)\n")
        f.write("            if cmd.get('type') == 'SELECT_OPTION':\n")
        f.write("                if 'options' in cmd:\n")
        f.write("                    for option in cmd['options']:\n")
        f.write("                         self._validate_commands(option, current_keys)\n")
        f.write("\n")

        f.write("    def _is_implicit_key(self, key):\n")
        f.write("        # List of keys provided by the engine context or event triggers\n")
        f.write("        known_implicits = {'EVENT_SOURCE', 'MANA_CIVILIZATION_COUNT'}\n")
        f.write("        return key in known_implicits\n")

    print(f"Generated {output_file}")

if __name__ == "__main__":
    main()
