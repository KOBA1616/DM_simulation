#!/usr/bin/env python3
"""
Replace call sites of `generate_legal_actions(` -> `generate_legal_commands(` safely.

Usage:
    python scripts/replace_generate_calls.py --path . --dry-run
    python scripts/replace_generate_calls.py --path . --apply --backup
"""
from __future__ import annotations
import argparse
import re
from pathlib import Path

CALL_RE = re.compile(r"\bgenerate_legal_actions\s*\(")
DEF_RE = re.compile(r"^\s*def\s+generate_legal_actions\s*\(")


def find_matches(root: Path):
    matches = {}
    for p in root.rglob("*.py"):
        try:
            text = p.read_text(encoding='utf-8')
        except Exception:
            continue
        lines = text.splitlines()
        hits = []
        for i, line in enumerate(lines, start=1):
            if CALL_RE.search(line):
                hits.append((i, line))
        if hits:
            matches[p] = hits
    return matches


def apply_replacement(path: Path, dry_run: bool = True, backup: bool = True) -> int:
    text = path.read_text(encoding='utf-8')
    lines = text.splitlines()
    new_lines = list(lines)
    replaced = 0
    for idx, line in enumerate(lines):
        if DEF_RE.match(line):
            continue
        if CALL_RE.search(line):
            new_line = CALL_RE.sub('generate_legal_commands(', line)
            if new_line != line:
                new_lines[idx] = new_line
                replaced += 1
    if replaced and not dry_run:
        if backup:
            bak = path.with_suffix(path.suffix + '.bak')
            bak.write_text(text, encoding='utf-8')
        path.write_text('\n'.join(new_lines) + ('\n' if text.endswith('\n') else ''), encoding='utf-8')
    return replaced


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--path', '-p', default='.', help='Repository root to scan')
    parser.add_argument('--dry-run', action='store_true', default=False)
    parser.add_argument('--apply', action='store_true', default=False)
    parser.add_argument('--backup', action='store_true', default=False)
    args = parser.parse_args()

    root = Path(args.path).resolve()
    matches = find_matches(root)
    total = sum(len(v) for v in matches.values())
    print(f"Found {total} occurrence(s) in {len(matches)} file(s).\n")
    for p, hits in sorted(matches.items(), key=lambda x: str(x[0])):
        print(f"{p}:")
        for ln, line in hits:
            flag = 'DEF' if DEF_RE.match(line) else 'CALL'
            print(f"  {flag} L{ln}: {line.strip()}")
        print()

    if args.apply:
        print('Applying replacements...')
        total_replaced = 0
        for p in matches.keys():
            replaced = apply_replacement(p, dry_run=False, backup=args.backup)
            if replaced:
                print(f"Patched {p}: {replaced} replacement(s)")
            total_replaced += replaced
        print(f"Done. Total replacements: {total_replaced}")
    else:
        print('Dry run complete. Re-run with --apply to modify files.')

if __name__ == '__main__':
    main()
