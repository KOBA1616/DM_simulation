# 18. 実装計画の実現可能性検討書 (Feasibility Analysis)

## 1. 概要
本ドキュメントは、新たに策定された要件定義（Spec 12～16）および詳細実装計画（Spec 17）について、現在のコードベース（v2.2時点）とのギャップを分析し、技術的な実現可能性を評価したものである。

## 2. 現状のコードベース分析 (Current State)
*   **C++エンジン**: `GameState`, `Player`, `CardInstance` などの基本構造は完成しており、`pybind11` を介したPython連携も正常に動作している。
*   **拡張性**: `GameState` は構造体として定義されており、メンバ変数の追加（`CardStats` マップ等）は容易である。
*   **パフォーマンス**: メモリプールやビットボードの一部導入により、シミュレーション速度は確保されている。

## 3. ギャップ分析とリスク評価

### 3.1 結果スタッツシステム (Spec 15)
*   **要件**: 16次元のスタッツ集計とベクトル化。
*   **実装箇所**: `src/core/card_stats.hpp` の新規作成と `GameState` への統合。
*   **リスク**: **低 (Low)**
    *   単純な数値集計であり、エンジンのコアロジック（ルール処理）への影響は軽微。
    *   メモリオーバーヘッドも `CardID` 数 × 16 × 8byte 程度であり、無視できるレベル。

### 3.2 非公開領域推論 (Spec 13)
*   **要件**: 公開領域のカード集計と、山札の確率分布計算。
*   **実装箇所**: `GameState::on_card_reveal` フックの実装。
*   **リスク**: **低 (Low)**
    *   カードが移動する箇所（`Zone`間の移動）は `GenericCardSystem` 等で一元管理されているため、フックの挿入は容易。
    *   計算コストも差分更新（O(1)）であるため、学習速度への影響はない。

### 3.3 シナリオ・トレーニング (Spec 16)
*   **要件**: 任意の盤面状態からのゲーム開始 (`reset_with_scenario`)。
*   **実装箇所**: `GameInstance` クラスの拡張。
*   **リスク**: **中 (Medium)**
    *   通常の手順（デッキロード → シャッフル → シールド展開 → 手札ドロー）をバイパスして状態を構築するため、**内部整合性（IDのユニーク性、フラグの矛盾など）** が崩れるリスクがある。
    *   **対策**: `reset_with_scenario` 内で厳密なバリデーションを行うか、ファクトリーメソッド経由でのみカードを生成する制約を設ける。
    *   **追加対策 (B. Data Creation)**: シナリオデータの作成コストを下げるため、将来的にはGeneric Card GeneratorのGUIを活用して盤面をエディットし、JSON出力する機能を実装する。

### 3.4 PBT & Kaggle統合 (Spec 12)
*   **要件**: Python側でのハイパーパラメータ変異と長時間学習管理。
*   **実装箇所**: Pythonスクリプトのみ。
*   **リスク**: **低 (Low)**
    *   C++エンジンには依存しないため、実装は容易。
    *   Kaggle APIの仕様変更や、データセットの容量制限（20GB以上は不可など）に注意が必要だが、テキストベースのログであれば問題ない。

### 3.5 その他の懸念事項 (Additional Concerns)

#### A. パフォーマンス (Performance overhead)
*   **懸念**: `ScenarioConfig` の頻繁な呼び出しや詳細な `CardStats` 収集がオーバーヘッドになる。
*   **対策**: Python↔C++間のデータ転送を最小化するため、Batch Inferenceの徹底および統計データ転送のバッチ化（エピソード終了時のみ集計）を行う。

#### C. 統計データの収束性 (Stats Convergence)
*   **懸念**: 16次元のスタッツが初期段階で不安定であり、学習を阻害する可能性がある。
*   **対策**: 以下の3段階のフェーズ運用を導入する。
    1.  **Mask Phase**: スタッツ入力を0にマスクし、基礎ルール学習に専念させる。
    2.  **Random Baseline Phase**: バックグラウンドでランダム対戦を行い、初期スタッツを収集する。
    3.  **Production Phase**: スタッツ入力を解禁し、自己対戦データで更新を続ける。

## 4. 結論 (Conclusion)
策定された実装計画は、現在のアーキテクチャ（C++ Core + Python Wrapper）と高い親和性を持っており、**技術的なブロッカーは存在しない**と判断する。
特に、詳細実装指示書（Spec 17）によりタスクが極小化されているため、AIアシスタントを用いた開発で十分に完遂可能である。

### 推奨される次のアクション
1.  **Phase 3 (AI Core Evolution)** の実装に着手する。
2.  特に `CardStats` の基盤を早急に整備し、データ収集を開始する。
