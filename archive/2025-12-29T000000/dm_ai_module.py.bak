"""
Compatibility shim loader for local development and tests.

This file provides a pure-Python fallback when the compiled
`dm_ai_module` extension is not available. For safety during
incremental edits, default to the Python fallback implementation.
"""

# Static type check suppression for this large compatibility shim.
# The pure-Python fallback contains many dynamic patterns that confuse
# static checkers (pyright/mypy). Suppress noisy reports here so that
# development can focus on runtime behavior and tests.
# pyright: reportGeneralTypeIssues=false
# pyright: reportMissingImports=false
# pyright: reportUnknownMemberType=false
# pyright: reportOptionalMemberAccess=false
# mypy: ignore-errors


from enum import Enum
from dataclasses import dataclass, field
from typing import Any, List, Dict, Optional

_compiled_module = None

# Global registry placeholder (some static checks reference this early).
_CARD_REGISTRY: Dict[int, Any] = {}

@dataclass
class CardDefinition:
    """Flexible card-definition used across tests: accepts fields commonly used
    by the fallback loader and JSON-backed CardData. Fields are optional to
    tolerate multiple shapes."""
    id: Optional[int] = None
    name: Optional[str] = None
    cost: Optional[int] = None
    civilization: Optional[str] = None
    civilizations: Optional[List[str]] = None
    power: Optional[int] = None
    type: Optional[str] = None
    keywords: Optional[List[Any]] = None
    effects: Optional[List[Any]] = None
    races: Optional[List[str]] = None

if _compiled_module is None:
    # Small compatibility helpers and minimal runtime types used by tests.
    def safe_int(x, default: int = -1) -> int:
        try:
            if x is None:
                return default
            return int(x)
        except Exception:
            return default

    # Minimal module helpers used by tests and external code.
    def register_card_data(card_map: Optional[Dict[int, Any]]):
        global _CARD_REGISTRY
        try:
            _CARD_REGISTRY = card_map or {}
        except Exception:
            _CARD_REGISTRY = {}

    class TriggerType(Enum):
        ON_PLAY = 'ON_PLAY'
        ON_ATTACK = 'ON_ATTACK'
        ON_DESTROY = 'ON_DESTROY'
        PASSIVE_CONST = 'PASSIVE_CONST'

    @dataclass
    class Action:
        type: Any = None
        player_id: int = 0
        card_id: Optional[int] = None
        source_instance_id: Optional[int] = None
        target_instance_id: Optional[int] = None
        amount: Optional[int] = None
        command: Any = None
        slot_index: Optional[int] = None

        def execute(self, state: 'GameState'):
            try:
                if hasattr(self, 'command') and self.command is not None:
                    try:
                        return self.command.execute(state)
                    except Exception:
                        return None
            except Exception:
                pass
            return None

    # --- Begin pure-Python fallback stubs (kept from original file) ---
    import json
    from types import SimpleNamespace
    from enum import Enum, IntEnum
    from dataclasses import dataclass, field
    from typing import Any, List, Dict, Optional

    class Civilization(Enum):
        FIRE = 'FIRE'
        WATER = 'WATER'
        NATURE = 'NATURE'
        LIGHT = 'LIGHT'
        DARKNESS = 'DARKNESS'

    class CardType(Enum):
        CREATURE = 'CREATURE'
        SPELL = 'SPELL'

    # Lightweight placeholders for compiled symbols referenced by tests during import.
    class Player:
        pass

    class GameEvent:
        def __init__(self, event_type=None, player_id: int = 0, from_zone: int = -1, to_zone: int = -1, context: Dict[str, Any] = None):
            self.type = event_type
            self.player_id = player_id
            self.from_zone = from_zone
            self.to_zone = to_zone
            self.context = context or {'from_zone': from_zone, 'to_zone': to_zone, 'player_id': player_id}

    class DeckEvolution:
        def __init__(self, card_db: Optional[Dict[int, Any]] = None):
            self.card_db = card_db or {}
        def get_candidates(self):
            return list(self.card_db.keys())
        def evolve_deck(self, current_deck: List[int], candidate_pool: List[int], config: Any):
            # Minimal evolution: return a shallow copy with occasional random swap
            try:
                import random
                rnd = random.Random(0)
                out = list(current_deck)
                if candidate_pool and len(out) > 0:
                    i = rnd.randrange(len(out))
                    out[i] = rnd.choice(candidate_pool)
                return out
            except Exception:
                return list(current_deck)
        def calculate_interaction_score(self, deck: List[int]) -> float:
            # Simple heuristic: prefer longer decks / basic score
            try:
                return float(len(deck))
            except Exception:
                return 0.0
        def get_candidates_by_civ(self, pool: List[int], civ: Any) -> List[int]:
            try:
                out = []
                for cid in pool:
                    cdef = (self.card_db or {}).get(cid)
                    if cdef is None:
                        continue
                    civs = getattr(cdef, 'civilizations', []) or []
                    if civ in civs or getattr(cdef, 'civilization', None) == civ:
                        out.append(cid)
                return out
            except Exception:
                return []

    class DeckEvolutionConfig:
        def __init__(self):
            self.target_deck_size = 40
            self.mutation_rate = 0.1

    class EffectType(Enum):
        NONE = 'NONE'
        TRIGGER_ABILITY = 'TRIGGER_ABILITY'
        META_COUNTER = 'META_COUNTER'

    class EventType(Enum):
        NONE = 'NONE'
        ZONE_ENTER = 'ZONE_ENTER'

    class GameStatus(Enum):
        PLAYING = 'PLAYING'
        WAITING_FOR_REACTION = 'WAITING_FOR_REACTION'

    class TriggerManager:
        def check_reactions(self, event: 'GameEvent', state: 'GameState', card_db: Optional[Dict[int, Any]] = None):
            try:
                # Minimal reaction detection: shield -> hand moves open reaction window
                ctx = getattr(event, 'context', {}) or {}
                to_zone = ctx.get('to_zone')
                from_zone = ctx.get('from_zone')
                instance_id = ctx.get('instance_id')
                if to_zone is None or from_zone is None:
                    return
                # If moved from SHIELD to HAND, open reaction window
                try:
                    if safe_int(to_zone) == int(Zone.HAND) and safe_int(from_zone) == int(Zone.SHIELD):
                        # Prepare minimal reaction state
                        try:
                            state.status = GameStatus.WAITING_FOR_REACTION
                        except Exception:
                            pass
                        # Store last reaction context so DeclareReactionCommand can reference it if needed
                        try:
                            state._last_reaction = {'instance_id': instance_id}
                        except Exception:
                            pass
                except Exception:
                    pass
            except Exception:
                pass


    class Zone(IntEnum):
        HAND = 0
        DECK = 1
        MANA_ZONE = 2
        SHIELD = 3
        GRAVEYARD = 4
        BATTLE = 5
        MANA = 6

    class Phase(IntEnum):
        MAIN = 0
        MANA = 1
        ATTACK = 2
        BLOCK = 3
        END_OF_TURN = 4

    # PhaseManager is defined later in the file; the later comprehensive
    # definition will be used. Avoid duplicating it here.

        @staticmethod
        def start_game(state, db: Optional[Dict[int, Any]] = None):
            try:
                try:
                    state._ensure_player(0)
                    state._ensure_player(1)
                except Exception:
                    pass
                try:
                    state.current_phase = Phase.MAIN
                except Exception:
                    pass
                try:
                    state.active_player_id = 0
                except Exception:
                    pass
            except Exception:
                pass

    class Command:
        """Minimal Command base for fallback implementations."""
        def execute(self, state):
            return None

    class DeclarePlayCommand(Command):
        def __init__(self, player_id: int, card_id: int, source_instance_id: Optional[int] = None):
            self.player_id = player_id
            self.card_id = card_id
            self.source_instance_id = source_instance_id

        def execute(self, state: 'GameState'):
            try:
                pid = safe_int(self.player_id or 0, 0)
                p = state.players[pid]
                moved = None
                for i, ci in enumerate(list(getattr(p, 'hand', []) or [])):
                    if getattr(ci, 'instance_id', None) == self.source_instance_id or getattr(ci, 'card_id', None) == self.card_id:
                        moved = p.hand.pop(i)
                        break
                if moved is not None:
                    entry = SimpleNamespace()
                    entry.type = 'DECLARE_PLAY'
                    entry.player_id = pid
                    entry.card_id = self.card_id
... (file truncated, archived copy contains full content)
